# **Recfa 论文核心阅读**
# **Recfa方案**

# **阶段 1：调用点过滤**

1. 筛选出不需要插桩的调用点。

   - 潜在监测点(PMP): 函数调用、间接跳转和在运行时由证明程序执行的返回

   - 可跳过调用点（SCSes）：用连续 pmp之间的因果关系判断是否pmp是否可以跳过

   - 我们为每个程序构建一个 **抽象图** 𝐺 = (𝑉, 𝐸) 来发现可

     - **节点集** 𝑉 包含所有 pmp以及那些没有调用点指向的函数的入口地址。

     - 如果对于任意 𝑣, 𝑣' ∈ 𝑉，我们发现从 𝑣 到 𝑣' 的控制流路径上没有中间节点 𝑣'' ∈ 𝑉，则在 𝐸 中添加一条有向边 (𝑣, 𝑣')。

   - 利用抽象图 𝐺可跳过某些节点，原则如下：

     - 当某个节点的所有前驱节点都只有他一个后继节点时，它是可跳过的。


2. 安全性保障：TODO

------

# **阶段 2：控制流事件折叠**

​	控制流折叠机制：有效地捕获未被跳过控制流事件，解决由 **循环和递归** 造成的数据量爆炸。

## 循环 折叠

### **循环 识别**：二进制程序中每个循环 **ℓ**，识别出四种关键点进行插桩：

- **循环入口** (ℓₑ)：循环的**起始点**，即程序进入循环体之前的位置
- **循环出口** (ℓₓ)：循环的**终止点**，即程序跳出循环的地方
- **循环体起始** (ℓₛ)：循环体内部的第一个基本块
- **循环体结束** (ℓ𝑑)：当前循环迭代的结束点，即将重新评估循环条件的位置。

### **循环 折叠机制**

1. 两个运行时数据结构：

   - **循环栈**：用于存储当前正在执行（未关闭）的循环状态（支持嵌套循环）。
     - **循环栈的每个元素** ：路径栈的一个索引，除了一些特殊的 **⊥ 标记** 用于区分内外层循环。
     - 每个索引表示路径栈中的某个**栈帧 ID**。


   - **路径栈** ：由多个**栈帧**组成，每个栈帧存储控制流事件（函数调用、返回、间接跳转），并将其**去重后**记录为事件路径。
     - 栈帧在执行特定循环时被捕获。
     - **内层循环的栈帧** 可以嵌套到**外层循环的栈帧**中


## **递归折叠**

### **递归识别**：检测**四种关键点**：

1. **递归函数的起始点和返回点** (𝑟𝑠, 𝑟𝑑)

2. **对递归函数的外部调用点** (𝑟𝑒)

3. **递归函数的外部调用结束点** (𝑟𝑥)，表示递归的结束

   ### 问题：该方法无法应用于相互递归

   1. 

# 例子

## 循环

![image-20250315140904492](.\1.png)

当程序计数器到达循环入口，即到达 𝑁0 的最后一条指令时，对循环栈进行插桩，推送一个标记 **⊥**。

当一个循环迭代开始时，即到达 𝑁1 的第一条指令，将路径栈的顶部标记为新事件路径的栈帧开始，并将路径栈的顶部索引推送到循环栈中。

在当前迭代的执行过程中，控制流事件将积累到新的栈帧中，形成一个事件路径，例如： **𝑝𝑖𝑑𝑥1 = {(𝑁3, 𝑁𝑝), (𝑁𝑝, 𝑁5)}**。

当这一迭代在 𝑁5 的最后一条指令结束时，我们将顶部事件路径 **𝑝𝑖𝑑𝑥1** 与循环栈中在 **⊥** 之上的事件路径进行比较。由于 **⊥** 上方没有其他事件路径，因此此时没有发现路径重复，**𝑝𝑖𝑑𝑥1** 被保留。

接着，第二次迭代从 𝑁1 到 𝑁5，新的事件路径 **𝑝𝑖𝑑𝑥2 = {(𝑁4, 𝑁𝑢), (𝑁𝑢, 𝑁5)}** 被积累到路径栈中。由于与 **𝑝𝑖𝑑𝑥1** 不同，**𝑝𝑖𝑑𝑥2** 也被保留。

从第三次迭代开始，积累的事件路径 **𝑝𝑖𝑑𝑥3** 应该与 **𝑝𝑖𝑑𝑥1** 或 **𝑝𝑖𝑑𝑥2** 中的某一个相同。由于发现了重复的事件路径，我们从路径栈和循环栈中分别弹出顶部事件路径 **𝑝𝑖𝑑𝑥3** 及其索引 **𝑖𝑑𝑥3**。

最后，当循环在 𝑁6 的第一条指令处结束时，我们从循环栈中弹出 **⊥** 之上的内容。

两个去重后的事件路径 **{(𝑁3, 𝑁𝑝), (𝑁𝑝, 𝑁5)}** 和 **{(𝑁4, 𝑁𝑢), (𝑁𝑢, 𝑁5)}** 将成为外层栈帧的一部分，继续进行外层循环的折叠。

## 递归

![image-20250315140927446](.\2.png)

在对函数 **func** 进行外部调用的地方，即在 **𝑁𝑏 的最后一条指令** 处，我们向**递归栈**（这里等价于循环栈）推送一个标记 **⊥**。

在 **func** 的起始点和返回点 (𝑟𝑠, 𝑟𝑑) 处，我们插桩去重操作，以检查当前累积的**顶部事件路径**（如果存在）是否与**递归栈**中**⊥ 之上的某个事件路径**相同。

如果发现**重复的事件路径**，则从**路径栈**和**递归栈**中分别弹出顶部事件路径及其索引。

### **递归过程中的事件路径处理**

- 首先，将事件路径 **{(𝑁𝑏, 𝑁1)}** 推入路径栈
- 然后，事件路径 **{(𝑁3, 𝑁1)}** 和 **{(𝑁5, 𝑁4)}** 被多次推入路径栈并去重
- 当递归结束，即到达 **𝑁𝑥 的起始位置** 时，事件路径 **{(𝑁5, 𝑁𝑥)}** 被推入路径栈
- 最后，我们**弹出递归栈中** **⊥ 之上的所有内容**，完成递归折叠

# 贪心压缩

1. 该算法**以阶段 2 生成的控制流事件序列作为输入**，并在压缩部分插入**若干“前导结点（leading knots）”**。

​		例如，对于控制流事件序列：**𝑒1𝑒2𝑒3𝑒4𝑒2𝑒3𝑒4𝑒5**，压缩后输出为：**𝑒1⟨2, 3⟩𝑒2𝑒3𝑒4𝑒5**其中，**⟨2, 3⟩ 代表长度为 3 的子序列（𝑒2𝑒3𝑒4）重复了 2 次**。1

# 实现

## 静态分析

在二进制检测之前，我们对证明器的程序二进制进行静态分析
